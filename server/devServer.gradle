import org.activityinfo.store.mysql.MySqlDatabase


// Generate the server's configuration on-the-fly based on this build's properties
def writeConfiguration(MySqlDatabase database, File outputFile) {
    Properties config = new Properties()
    config.setProperty("hibernate.connection.pool_size", "0")
    config.setProperty("hibernate.connection.driver_class", "com.mysql.jdbc.Driver")
    config.setProperty("hibernate.connection.username", database.server.username)
    config.setProperty("hibernate.connection.password", database.server.password)
    config.setProperty("hibernate.connection.url", database.url)
    
    // Point to the postmark stub service
    config.setProperty("postmark.url", "http://localhost:${postmarkStubPort}/email")
    config.setProperty("postmark.key", "POSTMARK_API_TEST")

    outputFile.withOutputStream { OutputStream out ->
        config.store(out, "Acceptance Test Configuration")
    }
}

task appengineExplodeDevMode(type: Copy) {
    group = "Google App Engine"
    description = "Creates a partial, exploded web app layout for GWT Dev Mode"
    
    // In order to run (super)dev mode, we need ONLY the part of the
    // web app required for the server side, which includes
    // compiled Java classes, resources, and server-side libraries
    
    dependsOn compileJava
    from("$projectDir/src/main/webapp")
    from(configurations.runtime) {
        into "WEB-INF/lib"
    }
    from(sourceSets.main.output) {
        into "WEB-INF/classes"
    }
    into "$buildDir/explodedDevMode"
}

task appengineDevMode(type: JavaExec) {
    dependsOn appengineExplodeDevMode
    dependsOn compileJava
    dependsOn project(':ui:app').tasks.getByName("compileJava")
    dependsOn project(':ui:app2').tasks.getByName("compileJava")


    main = 'com.google.gwt.dev.DevMode'

    classpath configurations.devServer

    // Java sources first, so that changes get picked up on refresh
    def sourceProjects = [":ui:app", ":ui:app2", ":i18n", ":clients:gwtrest", ":tools:json", ":tools:promises", ":model", ":analysis"];
    for(sourceProject in sourceProjects) {
        classpath project(sourceProject).sourceSets.main.java.srcDirs
        classpath project(sourceProject).sourceSets.main.resources.srcDirs
    }

    classpath project(':ui:app').sourceSets.main.runtimeClasspath
    classpath project(':ui:app2').sourceSets.main.runtimeClasspath

    // APT Generated sources
    classpath project(':ui:app').sourceSets.main.output.generatedSourcesDir

    for(sourceProject in sourceProjects) {
        classpath project(sourceProject).sourceSets.main.runtimeClasspath
    }


    // Server classes
    classpath sourceSets.main.runtimeClasspath

    args '-logLevel', 'WARN'
    args '-server', 'com.google.appengine.tools.development.gwt.AppEngineLauncher'
    args '-war', "${buildDir}/explodedDevMode"
    args '-startupUrl', 'login'
    args '-port', devServerPort
    args 'org.activityinfo.ui.ActivityInfoDevMode'
    args 'org.activityinfo.ui.AppDev'

    doFirst {

        def cloudSdkHome = new File('/usr/lib/google-cloud-sdk')
        if(!cloudSdkHome.exists()) {
            throw new RuntimeException("Google Cloud SDK not present in /usr/lib/google-cloud-sdk.\n" +
                    "Run sudo apt-get install google-cloud-sdk-app-engine-java");
        }

        def cloudSdkGaeJava = "${cloudSdkHome.absolutePath}/platform/google_appengine/google/appengine/tools/java"
        classpath "${cloudSdkGaeJava}/lib/appengine-tools-api.jar"


        // The appengine agent is a runtime agent that makes sure
        // we don't use any classes that are forbidden in the AppEngine environment.
        // However, it doesn't seem to have been updated for the new Java8 runtime.
        //
        // We can't remove the agent entirely, because the AppEngineLauncher class
        // will throw an error if it is not on the classpath. So, as a workaround,
        // place it on the classpath, but don't install it as an agent.

        classpath "${cloudSdkGaeJava}/lib/agent/appengine-agent.jar"


        // Write the application configuration pointing to the development database
        def configFile = project.file("$buildDir/config.properties")
        writeConfiguration mysql.localDev, configFile
        jvmArgs "-Dactivityinfo.config=${configFile}"
        jvmArgs "-Xdebug"
        jvmArgs "-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000"

        for(File classpathEntry : classpath) {
            logger.lifecycle("Classpath: " + classpathEntry)
        }
    }
}

// When running the devServer WITHOUT Gwt development,
// run on different port to avoid service worker messiness.

appengine {
    run {
        port = 8081
    }
}

appengineRun {

    doFirst {
        logger.lifecycle("Configuring database...")
        writeConfiguration  mysql.localDev, file("$buildDir/exploded-server/WEB-INF/activityinfo.properties")
    }
}
